Codeigniter Workshop Manual
===========================

The workshop will be held for three days with 5 session in total. Each session will start with simple explanation and hands on example. Then it is followed by excercises for the parcipant to try and experience the details of each example.

Few assumptions before starting:

- Participants are familiar with programming with PHP
- Participants are using Windows OS
- Internet connection are available

Sessions Topic are as follows:

- Session 0: **Environment Preparation**  
- Session 1: **Intro to CodeIgniter (Installation and PreTest)**  
- Session 2: **MVC Pattern With CodeIgniter**  
- Session 3: **CodeIgniter Common Tools and Helpers**  
- Session 4: **Custom Library and Helpers**  
- Session 5: **CodeIgniter Best Practice**
- Project: **Simple ACL and News Board ala Reddit**

The What
--------

CodeIgniter is an Application Development Framework - a toolkit - for people who build web sites using PHP. Its goal is to enable you to **develop projects much faster** than you could if you were writing code from scratch, by providing a rich set of libraries for commonly needed tasks, as well as a **simple interface** and **logical structure** to access these libraries. CodeIgniter lets you creatively focus on your project by minimizing the amount of code needed for a given task.

The Why
-------

CodeIgniter is right for you if:

- You want a framework with a **small footprint**.
- You need **exceptional performance**.
- You need **broad compatibility with standard hosting** accounts that run a variety of PHP versions and configurations.
- You want a framework that requires **nearly zero configuration**.
- You want a framework that **does not require you to use the command line**.
- You want a framework that **does not require you to adhere to restrictive coding rules**.
- You do not want to be forced to learn a templating language (although a template parser is optionally available if you desire one).
- You eschew complexity, favoring **simple solutions**.
- You need clear, **thorough documentation**.


Session 0 : Environment Preparation
===================================

Before we can start, we need to make sure our tools are well prepared. This workshop use only 2 tools which is Sublime Text 2 as text editor and WAMPP as our local server.

Sublime Text 2
--------------
Example are written using text editor Sublime Text 2. Download it [here](http://sublimetext.com) and install it.

![Download Sublime Text 2](https://raw.github.com/robotys/ci_manual/master/assets/sublime_download.png)

*Sublime Text 2 Download Page*

![Sublime Text 2 UI Example](https://raw.github.com/robotys/ci_manual/master/assets/sublime_example.png)

*Sublime Text Example*


WAMPP
-----

Apache, MySQL, PHP and PHPMyAdmin were installed using WAMPP packaged. Download it here and install it. Please make sure to install Microsoft C++ redistributable package before installing WAMPP.


Session 1:  Intro to CodeIgniter (Installation and PreTest)
===========================================================

CODEIGNITER AT A GLANCE
-----------------------
	
Some overview about CodeIgniter


CodeIgniter is an Application Framework
---------------------------------------
CodeIgniter is a toolkit for people who build web applications using PHP. Its goal is to enable you to develop projects much faster than you could if you were writing code from scratch, by providing a rich set of libraries for commonly needed tasks, as well as a simple interface and logical structure to access these libraries. CodeIgniter lets you creatively focus on your project by minimizing the amount of code needed for a given task.

CodeIgniter is Free
-------------------
CodeIgniter is licensed under an Apache/BSD-style open source license so you can use it however you please. For more information please read the license agreement.

CodeIgniter is Light Weight
---------------------------
Truly light weight. The core system requires only a few very small libraries. This is in stark contrast to many frameworks that require significantly more resources. Additional libraries are loaded dynamically upon request, based on your needs for a given process, so the base system is very lean and quite fast.

CodeIgniter is Fast
-------------------
Really fast. We challenge you to find a framework that has better performance than CodeIgniter.

CodeIgniter Uses M-V-C
----------------------
CodeIgniter uses the Model-View-Controller approach, which allows great separation between logic and presentation. This is particularly good for projects in which designers are working with your template files, as the code these file contain will be minimized. We describe MVC in more detail on its own page.

CodeIgniter Generates Clean URLs
--------------------------------
The URLs generated by CodeIgniter are clean and search-engine friendly. Rather than using the standard "query string" approach to URLs that is synonymous with dynamic systems, CodeIgniter uses a segment-based approach:

example.com/news/article/345
> Note: By default the index.php file is included in the URL but it can be removed using a simple .htaccess file.

CodeIgniter Packs a Punch
-------------------------
CodeIgniter comes with full-range of libraries that enable the most commonly needed web development tasks, like accessing a database, sending email, validating form data, maintaining sessions, manipulating images, working with XML-RPC data and much more.

CodeIgniter is Extensible
--------------------------
The system can be easily extended through the use of your own libraries, helpers, or through class extensions or system hooks.

CodeIgniter Does Not Require a Template Engine
----------------------------------------------
Although CodeIgniter does come with a simple template parser that can be optionally used, it does not force you to use one. Template engines simply can not match the performance of native PHP, and the syntax that must be learned to use a template engine is usually only marginally easier than learning the basics of PHP. Consider this block of PHP code:

	<ul>

	<?php foreach ($addressbook as $name):?>

	<li><?=$name?></li>

	<?php endforeach; ?>

	</ul>


Contrast this with the pseudo-code used by a template engine:

	<ul>

	{foreach from=$addressbook item="name"}

	<li>{$name}</li>

	{/foreach}

	</ul>

Yes, the template engine example is a bit cleaner, but it comes at the price of performance, as the pseudo-code must be converted back into PHP to run. Since one of our goals is maximum performance, we opted to not require the use of a template engine.

CodeIgniter is Thoroughly Documented
------------------------------------

Programmers love to code and hate to write documentation. We're no different, of course, but since documentation is as important as the code itself, we are committed to doing it. Our source code is extremely clean and well commented as well.

INSTALLATION
------------

Download Codeigniter [here](http://codeigniter.com/download.php)

Extract (unzip) to home folder (www or htdocs) so it looks like this:

	-www
	  -codeigniter
		-application
		-system
		-user_guide
		-index.php

If you like, change the name codeigniter into CI, so its simple to be called afterwards.

	-www
	  -ci
		-application
		-system
		-user_guide
		-index.php

However, we can change the folder structure to whatever we like. Structure as depicted below are quite widely used for codeigniter:
		
	-www
	  -app_name
		-application
		-index.php
	  -another_app
		-application
		-index.php
	  -ci_system

Just make sure we specify the location of systems file for the application to approriate location. Open the index.php file and change the system path to the new one:

	$system_path = '../ci_system';

This folder structure can cater multiple application within one domain with only one codeigniter core files (system). 

This make the upgrading easier and faster. To use multiple Codeigniter core for multiple application, so that we can fallback gracefully should something happen, we can use folder structure as below:

	-www
	  -app_name
		-application
		-index.php
	  -another_app
		-application
		-index.php
	  -ci_system_v21
	  -ci_system_v22

... and specify which application to use which version of codeigniter in its own index.php.

Test the installation by loading the app via url: http://localhost/app_name

Latest 'test page' design should be like below:

![Codeigniter Welcome page](https://raw.github.com/robotys/ci_manual/master/assets/ci_welcome.png)

And thus your installation is now complete! For some *nightmare* you can open application folder and wonder what is all the folder and files are doing. 

(Or you can always open the user_guide folder tor the helpful documents.)

> **Exercise 0: Your App**  
Create your codeigniter App with system folder outside of your app_folder. Make sure the test page run fine.


/debug

Session 2: MVC Pattern With CodeIgniter
=======================================

Codeigniter assume the codes are structured into MVC pattern. MVC separate the concerns of codes into 3 distinct function namely:

1. 	**Models**   
	Models are where the heavy processing is done. All the business process, database operation (CRUD) is done here. We always prefer Fat Models over Fat Controller
2.	**Controller**   
	Controller is the one who route the url to specified php class and method. Controller acts like traffic light which control the flow of data to be processed and flow of page to be display as view.
3.	**View**   
	View only manage the front-end aspect of our web app. All the designs/htmls and CSS are manage by view part of MVC.


CodeIgniter has a fairly loose approach to MVC since **Models are not required**. If you don't need the added separation, or find that maintaining models requires more complexity than you want, you **can ignore them** and build your application minimally using Controllers and Views. 

>	CodeIgniter also enables you to incorporate your own existing scripts, or even develop core libraries for the system, enabling you to work in a way that makes the most sense to you.

The simplest flow of information for CodeIgniter app are as followed:

1.	A page is requested via url. Lets say Dashboard page. The url used is http://localhost/app_name/index.php/dashboard
2.	Codeigniter System will translate the uri and run the method **index** in class **Dashboard** from php file named **dashboard.php** inside *app_name/application/controller* folder.

		-www
		  -app_name
			-application
				-controllers
					-dashboard.php
			-index.php
		  -ci_system
	
	dashboard.php contains codes as below:

```php
	class Dashboard extend CI_Controller{	
		function index(){
			echo 'Welcome To Dashboard';
		}
	} 
```	
		
	
here we can see that Codeigniter will run and display 'Welcome To Dashboard'. No Models and Views involved in this example.

More complex example when the data, lets say the string 'Welcome To Dashboard' is processed from models and the send to view files.

For this example we will create two new files at *application/models/m_dashboard.php* and another one at *application/view/v_dashboard.php*:

	-www
	  -app_name
		-application
			-controllers
				-dashboard.php
			-models
				-m_dashboard.php
			-views
				-v_dashboard.php
		-index.php
	  -ci_system

Change the **dashboard.php** into this:
	

```php
	class Dashboard extend CI_Controller{
		function index(){
			$this->load->model('m_dashboard');
			$str = $this->m_dashboard->index_data();
			
			$data['index'] = $str;
			
			$this->load->view('v_dashboard, $data);
		}
	}
```
	

As we can see, the dashboard controller will first load the models that it need by using load method. This load method is inherited from CI_Controller parent. 

All models loaded can then be called via *$this->model_name->model_method()* to initiate the models method process. Here we will run method *index_data()* which will return the string 'Welcome To Dashboard'.

Fill the **m_dashboard.php** file with codes as below:

	class M_dashboard extend CI_Model{
		function index_data(){
			return 'Welcome To Dashboard';
		}
	}

It is really direct. The code will return string 'Welcome To Dashboard' to whoever calling it.

As per example, the one who call it is variable $str in dashboard controller.

The string then loaded into array $data with key 'index' and sent to view via load method second parameter as shown in the example.

	$this->load->view('view_files', $second_parameter);

THe view files then will capture the string into new variable based on the key. So here, the key contain the string within array data is 'index', thus in view files codeigniter will spawn new variable with the name $index containing the string.

Fill in the **v_dashboard.php** files with the codes below:
	

```php
	<html>
		<head>
			<title>Dashboard</title>
		</head>
	<body>
		<?php
			echo '<h1>'.$index.'</h1>';
		?>
	</body>
	</html>
```
We can see that v_dashboard.php resembles a lot like plain html files. Keep in mind that view files are like front end template to our application and we will populate it from data sent from controller. Example here is the string 'Welcome To Dashboard' which was sent in variable $index.

> **Exercise 1: Add new page**    
> Add new page which is linked from dashboard to url *http://localhost/app_name/index.php/dashboard/info* . The view page should display php_info() details.


> **Exercise 2: Views List**    
> Add new page which is linked from dashboard to url *http://localhost/app_name/index.php/admin/view_list* . The view page should display all file names within view directory dynamically.


Session 2.1: MVC with string from MySQL DB
------------------------------------------

A lot of data we need usually reside in mysql database. Codeigniter is not limited to only MySQL. In fact CI can connect to multitude of DB engine via its powerful DB connectors wizard.

But MySQL is good enough for example.

Before we start we need to have the connection to MySQL DB.

Open database.php within config directory located at *www/app_name/application/config/database.php*. Change the details to reflect your MySQL connection. As this is local MySQL under WAMP, we can just use the default username and password.

the three important details to be changed are:
	

```php 
	52:		$db['default']['username'] = 'root';
	53:		$db['default']['password'] = '';
	54:		$db['default']['database'] = 'ci_workshop';
```
	
After that, we need to create and populate a MySQL database 'ci_workshop' with appropriate table and data. CI has great tools for Database Management within Database Class. The tools is Database Forge. 

Create new method in *m_dashboard.php* called db_init and type the codes below:
	

```php
	class M_dashboard extend CI_Model{
		function index_data(){
			return 'Welcome To Dashboard';
		}

		function db_init()
		{
			//load database tools
			$this->load->dbforge();
	
			//create database 'ci_workshop'
			if ($this->dbforge->create_database('ci_workshop'))
			{
			    echo 'Database created!<br/>';
			}
			
			//declare fields for our table
			$fields = array(
	            'id' => array(
	                         'type' => 'INT',
	                         'constraint' => 5, 
	                         'unsigned' => TRUE,
	                         'auto_increment' => TRUE
	                  ),
	            'key' => array(
	                         'type' => 'VARCHAR',
	                         'constraint' => '100',
	                  ),
	            'value' => array(
	                         'type' => 'text',
	                  )
	        );
	
			//add fields to dbforge tools
	        $this->dbforge->add_field($fields);
	
	        //set column id as Primary key
	        $this->dbforge->add_key('id', TRUE);
	
	        //create table if not exists
	        $this->dbforge->create_table('kv_store', TRUE);
	
	        //load database
			$this->load->database();
	
			//insert string value to table
			$this->db->insert('kv_store', array('key'=>'dashboard_welcome','value'=>'Welcome To Dashboard'));
		}
	}
```
	

Change the **dashboard.php** into this:
	

```php
	class Dashboard extend CI_Controller{
		function index(){
			$this->load->model('m_dashboard');
			$str = $this->m_dashboard->index_data();
			
			$data['index'] = $str;
			
			$this->load->view('v_dashboard, $data);
		}

		function init_db(){
			$this->load->model('m_dashboard');
			$this->m_dashboard->db_init();

			echo 'DB now ready!';
		}
	}
```
	

Run the database initiation by visiting page init_db at *http://localhost/ci_workshop/index.php/dashboard/init_db*

If we check in our PhpMyAdmin, we can see that new row has been added in our kv_store table as shown:

![Welcome string in DB](https://raw.github.com/robotys/ci_manual/master/assets/db_welcome.png)

Now, to use the strng in our models.

Open our m_dashboard.php files and change the code to be like the code shown below:

	class M_dashboard extend CI_Model{
		function index_data(){
			$this->load->database();

			$this->db->where('key','dashboard_welcome');
			$query = $this->db->get('kv_store');
			
			$res = $query->result_array();
			return $res[0]['value'];
		}
	}

When we run the dashboard page again we will get the same "Welcome To Dashboard" string but it is now reside inside a database. We thus can make a basic CRUD interface to manage the string afterwards.

	

Session 3: CodeIgniter Common Tools and Helpers  
===============================================
	
CodeIgniter come with multitude of tools to help our application development. Anything that is conceived for us to be used should already be there in CodeIgniter bag of tools.
	
The tools come from two different place namely Library and Helpers.
	
Codeigniter Library
-------------------

CodeIgniter Library is a collection of PHP **Class** which focus on single domain of usage. Among widely use Codeigniter Library are:

- **Session Class**  
	Manage $_SESSION but we can choose to make the session either as protected cookies or a table in DB.
- **Form Validation Class**   
	Manage input validation before processing. Use with Input Class. Validation include email validation, min,max, numeric, alphanumeric and custom function (usually to check username availability). 
- **Input Class**   
	Manage native $_POST, $_GET and $_SERVER global variable. Automatically sanitize the value before process. 
- **Email Class**  
	Ultimate tools to send email via PHP script. All type of configuration and email types (plain text, html email, attachment) available.
- **File Uploading Class**   
	Manage file uploads function gracefully. Simple and elegant solution.
- **URI Class**   
	To help with URL segmentation and manipulation. From URI string to array and vice versa. Best used to manage complex ACL.
- **Database Class**   
	The most beloved class especially in Model. Among smaller tools within database class is Active Record which can add structure and logic to our SQL query.
- **Caching Class**   
	Simple yet effective caching solution. Can be extend to use external caching tools to make it more efficient and powerfull.


Codeigniter Helper
------------------

Codeigniter Helper is a collection of **functions** that can be use to help us in developing our application. Helpers differ from Library in sense of helper is a function while Library is a method within a class. Helpers is more focused as a tool and thus only cater limited usage space.
	
Among usefull helpers are:

- **Download Helper**   
	Assist us in creating a download page. All type of files can be used. received filename and binary data as parameters. 

- **Email Helper**   
	Two functions within this helper are ```valid_email('string@email')``` to validate email string and ```send_email('recipient','subject','message')``` to send plain text email. Simple and functional.

- **Form Helper**   
	Assist us in creating html form and input tags. May not be shorter than html but its usefullness come from its powerfull logic and configurations.

- **URL Helper**   
	Assist us in generating uri within Codeigniter application. Thus we not need to change every links as it is now dynamically generated by codeigniter.


Some of the library need to be loaded first before it can be used while other are automatically loaded. Helpers are always needed to be loaded.

Below are the functionlity of said Class and Helpers:
	
Session Class
-------------

The Session class permits you maintain a user's "state" and track their activity while they browse your site. The Session class stores session information for each user as serialized (and optionally encrypted) data in a cookie. 
	
It can also store the session data in a database table for added security, as this permits the session ID in the user's cookie to be matched against the stored session ID. By default only the cookie is saved. If you choose to use the database option you'll need to create the session table as indicated below.

**INITIALIZE**

Sessions will typically run globally with each page load, so the session class must either be initialized in your controller constructors, or it can be auto-loaded by the system. For the most part the session class will run unattended in the background, so simply initializing the class will cause it to read, create, and update sessions.

To initialize the Session class manually in your controller constructor, use the ```$this->load->library``` function:

	$this->load->library('session');

Once loaded, the Sessions library object will be available using: ```$this->session```

**How do Sessions work?**

When a page is loaded, the session class will check to see if valid session data exists in the user's session cookie. If sessions data does not exist (or if it has expired) a new session will be created and saved in the cookie. If a session does exist, its information will be updated and the cookie will be updated. With each update, the session_id will be regenerated.

It's important for you to understand that once initialized, the Session class runs automatically. There is nothing you need to do to cause the above behavior to happen. You can, as you'll see below, work with session data or even add your own data to a user's session, but the process of reading, writing, and updating a session is automatic.

**USAGE**
	
		
	//Load the library
		$this->load->library('session');
	
	//set new session value like array.
		$this->session->set_userdata($array); 
	///usage:
		$newdata = array(
	                   'username'  => 'johndoe',
	                   'email'     => 'johndoe@some-site.com',
	                   'logged_in' => TRUE
	               );

		$this->session->set_userdata($newdata);
	//or like this also can:
		$this->session->set_userdata('some_name', 'some_value');

	//retrieve session with key 'item'
		$this->session->userdata('item'); 
	//example of usage: 
		$session_id = $this->session->userdata('session_id');
	
	
	//Retrieve All Session Data
		$this->session->all_userdata()
	
	//Unset Session Data
		$this->session->unset_userdata('some_name');
	
	//Session Destroy
		$this->session->sess_destroy();

Thats a simple all in one how to use Codeigniter Session Library

> **Brain Nuggets:**   
	Think a login and login system using Codeigniter Session

	
Form Validation
---------------


**OVERVIEW**

Before explaining CodeIgniter's approach to data validation, let's describe the ideal scenario:

1. A form is displayed.
2. You fill it in and submit it.
3. If you submitted something invalid, or perhaps missed a required item, the form is redisplayed containing your data along with an error message describing the problem.
4. This process continues until you have submitted a valid form.

On the receiving end, the script must:

1. Check for required data.
2. Verify that the data is of the correct type, and meets the correct criteria. For example, if a username is submitted it must be validated to contain only permitted characters. It must be of a minimum length, and not exceed a maximum length. The username can't be someone else's existing username, or perhaps even a reserved word. Etc.
3. Sanitize the data for security.
4. Pre-format the data if needed (Does the data need to be trimmed? HTML encoded? Etc.)
5. Prep the data for insertion in the database.

Although there is nothing terribly complex about the above process, it usually requires a significant amount of code, and to display error messages, various control structures are usually placed within the form HTML. Form validation, while simple to create, is generally very messy and tedious to implement.


**Form Validation Tutorial**

What follows is a "hands on" tutorial for implementing CodeIgniters Form Validation.

In order to implement form validation you'll need three things:

A View file containing a form.
A View file containing a "success" message to be displayed upon successful submission.
A controller function to receive and process the submitted data.
Let's create those three things, using a member sign-up form as the example.

**The Form**

Using a text editor, create a form called myform.php. In it, place this code and save it to your applications/views/ folder:

	<html>
	<head>
	<title>My Form</title>
	</head>
	<body>

	<?php echo validation_errors('<div class="error">', '</div>'); ?>

	<?php echo form_open('form'); ?>

	<h5>Username</h5>
	<input type="text" name="username" value="<?php echo set_value('username'); ?>" size="50" />

	<h5>Password</h5>
	<input type="text" name="password" value="<?php echo set_value('password'); ?>" size="50" />

	<h5>Password Confirm</h5>
	<input type="text" name="passconf" value="<?php echo set_value('passconf'); ?>" size="50" />

	<h5>Email Address</h5>
	<input type="text" name="email" value="<?php echo set_value('email'); ?>" size="50" />

	<div><input type="submit" value="Submit" /></div>

	</form>

	</body>
	</html>


**The Success Page**

Using a text editor, create a form called formsuccess.php. In it, place this code and save it to your applications/views/ folder:

	<html>
	<head>
	<title>My Form</title>
	</head>
	<body>

	<h3>Your form was successfully submitted!</h3>

	<p><?php echo anchor('form', 'Try it again!'); ?></p>

	</body>
	</html>


**The Controller**

Using a text editor, create a controller called form.php. In it, place this code and save it to your applications/controllers/ folder:


	class Form extends CI_Controller {

		function index()
		{
			
		//load form and url helper
			$this->load->helper(array('form', 'url'));
				
		//load form validation class
			$this->load->library('form_validation');
				
		//set validation rules for all 
			$this->form_validation->set_rules('username', 'Username', 'trim|callback_username_check|required|min_length[5]|max_length[12]|xss_clean');
			$this->form_validation->set_rules('password', 'Password', 'trim|required|matches[passconf]|md5');
			$this->form_validation->set_rules('passconf', 'Password Confirmation', 'trim|required');
			$this->form_validation->set_rules('email', 'Email', 'trim|required|valid_email');

		//run validation, if false display myform, if true display formsuccess		
			if ($this->form_validation->run() == FALSE)
			{
				$this->load->view('myform');
			}
			else
			{
				$this->load->view('formsuccess');
			}
		}
	
		
		//Special function to check if the username is allowed to be used.
		public function username_check($str)
		{
			if ($str == 'test')
			{
			
			//set error message for username_check rules.
				$this->form_validation->set_message('username_check', 'The %s field can not be the word "test"');
				return FALSE;
			}
			else
			{
				return TRUE;
			}
		}
			
		
	}
	

To test the application, open ```http://localhost/ci_workshop/index.php/form```, complete the form and hit enter. Play with the application to try the validation.
	
**EXPLANATION**

There is three main section of Form Validation Class which is 1: Error Display, 2: Validation Rules and 3: Run Validation. The one with the most complexity among the three are Validation Rules.
	
The validation process basically are like below:
	
1. Validation start with capturing the input from html form via input class.
2. The value then will be run through all the required rules which has been setup in validation rules section.
3. Any error while validating will be notified via Error Display function (validation_errors).

	

**RULE REFERENCE**

The following is a list of all the native rules that are available to use:

<table cellpadding="0" cellspacing="1" border="0" style="width:100%" class="tableborder">
	<tr>
		<td><b>Rule</b></td>
		<td><b>Parameter</b></td>
		<td><b>Description</b></td>
		<td><b>Example</b></td>
	</tr>

	<tr>
		<td class="td"><strong>required</strong></td>
		<td class="td">No</td>
		<td class="td">Returns FALSE if the form element is empty.</td>
		<td class="td">&nbsp;</td>
	</tr>

	<tr>
		<td class="td"><strong>matches</strong></td>
		<td class="td">Yes</td>
		<td class="td">Returns FALSE if the form element does not match the one in the parameter.</td>
		<td class="td">matches[form_item]</td>
	</tr>

	<tr>
		<td class="td"><strong>is_unique</strong></td>
		<td class="td">Yes</td>
		<td class="td">Returns FALSE if the form element is not unique to the table and field name in the parameter.</td>
		<td class="td">is_unique[table.field]</td>
	</tr>

	<tr>
		<td class="td"><strong>min_length</strong></td>
		<td class="td">Yes</td>
		<td class="td">Returns FALSE if the form element is shorter then the parameter value.</td>
		<td class="td">min_length[6]</td>
	</tr>

	<tr>
		<td class="td"><strong>max_length</strong></td>
		<td class="td">Yes</td>
		<td class="td">Returns FALSE if the form element is longer then the parameter value.</td>
		<td class="td">max_length[12]</td>
	</tr>

	<tr>
		<td class="td"><strong>exact_length</strong></td>
		<td class="td">Yes</td>
		<td class="td">Returns FALSE if the form element is not exactly the parameter value.</td>
		<td class="td">exact_length[8]</td>
	</tr>

	<tr>
		<td class="td"><strong>greater_than</strong></td>
		<td class="td">Yes</td>
		<td class="td">Returns FALSE if the form element is less than the parameter value or not numeric.</td>
		<td class="td">greater_than[8]</td>
	</tr>

	<tr>
		<td class="td"><strong>less_than</strong></td>
		<td class="td">Yes</td>
		<td class="td">Returns FALSE if the form element is greater than the parameter value or not numeric.</td>
		<td class="td">less_than[8]</td>
	</tr>

	<tr>
		<td class="td"><strong>alpha</strong></td>
		<td class="td">No</td>
		<td class="td">Returns FALSE if the form element contains anything other than alphabetical characters.</td>
		<td class="td">&nbsp;</td>
	</tr>

	<tr>
		<td class="td"><strong>alpha_numeric</strong></td>
		<td class="td">No</td>
		<td class="td">Returns FALSE if the form element contains anything other than alpha-numeric characters.</td>
		<td class="td">&nbsp;</td>
	</tr>

	<tr>
		<td class="td"><strong>alpha_dash</strong></td>
		<td class="td">No</td>
		<td class="td">Returns FALSE if the form element contains anything other than alpha-numeric characters, underscores or dashes.</td>
		<td class="td">&nbsp;</td>
	</tr>

	<tr>
		<td class="td"><strong>numeric</strong></td>
		<td class="td">No</td>
		<td class="td">Returns FALSE if the form element contains anything other than numeric characters.</td>
		<td class="td">&nbsp;</td>
	</tr>

	<tr>
		<td class="td"><strong>integer</strong></td>
		<td class="td">No</td>
		<td class="td">Returns FALSE if the form element contains anything other than an integer.</td>
		<td class="td">&nbsp;</td>
	</tr>

	<tr>
		<td class="td"><strong>decimal</strong></td>
		<td class="td">Yes</td>
		<td class="td">Returns FALSE if the form element is not exactly the parameter value.</td>
		<td class="td">&nbsp;</td>
	</tr>

	<tr>
		<td class="td"><strong>is_natural</strong></td>
		<td class="td">No</td>
		<td class="td">Returns FALSE if the form element contains anything other than a natural number: 0, 1, 2, 3, etc.</td>
		<td class="td">&nbsp;</td>
	</tr>

	<tr>
		<td class="td"><strong>is_natural_no_zero</strong></td>
		<td class="td">No</td>
		<td class="td">Returns FALSE if the form element contains anything other than a natural number, but not zero: 1, 2, 3, etc.</td>
		<td class="td">&nbsp;</td>
	</tr>

	<tr>
		<td class="td"><strong>valid_email</strong></td>
		<td class="td">No</td>
		<td class="td">Returns FALSE if the form element does not contain a valid email address.</td>
		<td class="td">&nbsp;</td>
	</tr>

	<tr>
		<td class="td"><strong>valid_emails</strong></td>
		<td class="td">No</td>
		<td class="td">Returns FALSE if any value provided in a comma separated list is not a valid email.</td>
		<td class="td">&nbsp;</td>
	</tr>

	<tr>
		<td class="td"><strong>valid_ip</strong></td>
		<td class="td">No</td>
		<td class="td">Returns FALSE if the supplied IP is not valid.</td>
		<td class="td">&nbsp;</td>
	</tr>

	<tr>
		<td class="td"><strong>valid_base64</strong></td>
		<td class="td">No</td>
		<td class="td">Returns FALSE if the supplied string contains anything other than valid Base64 characters.</td>
		<td class="td">&nbsp;</td>
	</tr>


</table>

<p><strong>Note:</strong> These rules can also be called as discrete functions. For example:</p>

<code>$this->form_validation->required($string);</code>

<p class="important"><strong>Note:</strong> You can also use any native PHP functions that permit one parameter.</p>


Input Clas
----------
Email Class
-----------
File Uploading Class
--------------------
URI Class
---------
Database Class
--------------
Caching Class
-------------
Download Helper
---------------
Email Helper
------------
Form Helper
-----------
URL Helper
----------




	

Session 4: Custom Library and Helpers
=====================================

Both Library Class and Helpers function can be used and fused together to create new Library or Helpers. That new library and helpers can then be used in our codes. This give use huge flexibility towards building our own set of application.
	
CREATING LIBRARIES
------------------

When we use the term "Libraries" we are normally referring to the classes that are located in the libraries directory and described in the Class Reference of this user guide. In this case, however, we will instead describe how you can create your own libraries within your application/libraries directory in order to maintain separation between your local resources and the global framework resources.

As an added bonus, CodeIgniter permits your libraries to extend native classes if you simply need to add some functionality to an existing library. Or you can even replace native libraries just by placing identically named versions in your application/libraries folder.

In summary:

- You can create entirely new libraries.
- You can extend native libraries.
- You can replace native libraries.

The page below explains these three concepts in detail.

> Note: The Database classes can not be extended or replaced with your own classes. All other classes are able to be replaced/extended.

Storage
-------

Your library classes should be placed within your ```application/libraries``` folder, as this is where CodeIgniter will look for them when they are initialized.

Naming Conventions
------------------

- File names must be capitalized. For example:  Myclass.php
- Class declarations must be capitalized. For example:  class Myclass
- Class names and file names must match.

The Class File
--------------

Classes should have this basic prototype (Note: We are using the name Someclass purely as an example):

	<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed'); 

	class Someclass {

	    public function some_function()
	    {
	    }
	}

	/* End of file Someclass.php */
		
	
Using Your Class
----------------

From within any of your Controller functions you can initialize your class using the standard:

	$this->load->library('someclass');
	
Where someclass is the file name, without the ".php" file extension. You can submit the file name capitalized or lower case. CodeIgniter doesn't care.

Once loaded you can access your class using the lower case version:

	$this->someclass->some_function();  // Object instances will always be lower case

Passing Parameters When Initializing Your Class
-----------------------------------------------

In the library loading function you can dynamically pass data as an array via the second parameter and it will be passed to your class constructor:

	$params = array('type' => 'large', 'color' => 'red');

	$this->load->library('Someclass', $params);
	
If you use this feature you must set up your class constructor to expect data:

	<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');

	class Someclass {

	    public function __construct($params)
	    {
	        // Do something with $params
	    }
	}

	?>

You can also pass parameters stored in a config file. Simply create a config file named identically to the class file name and store it in your ```application/config/``` folder. Note that if you dynamically pass parameters as described above, the config file option will not be available.

Utilizing CodeIgniter Resources within Your Library
---------------------------------------------------

To access CodeIgniter's native resources within your library use the ```get_instance()``` function. This function returns the **CodeIgniter super object**.

Normally from within your controller functions you will call any of the available CodeIgniter functions using the ```$this``` construct:

	$this->load->helper('url');
	$this->load->library('session');
	$this->config->item('base_url');
	etc.

```$this```, however, only works directly within your controllers, your models, or your views. If you would like to use CodeIgniter's classes from within your own custom classes you can do so as follows:

First, assign the CodeIgniter object to a variable:

	$CI =& get_instance();

Once you've assigned the object to a variable, you'll use that variable instead of $this:

	$CI =& get_instance();

	$CI->load->helper('url');
	$CI->load->library('session');
	$CI->config->item('base_url');
	etc.

> Note: You'll notice that the above get_instance() function is being passed by reference: 
> 	$CI =& get_instance(); 
> This is very important. Assigning by reference allows you to use the original CodeIgniter object rather than creating a copy of it.

Replacing Native Libraries with Your Versions
---------------------------------------------

Simply by naming your class files identically to a native library will cause CodeIgniter to use it instead of the native one. To use this feature you must name the file and the class declaration exactly the same as the native library. For example, to replace the native Email library you'll create a file named application/libraries/Email.php, and declare your class with:

	class CI_Email {

	}

Note that most native classes are prefixed with CI_.

To load your library you'll see the standard loading function:

	$this->load->library('email');
	
> Note: At this time the Database classes can not be replaced with your own versions.

Extending Native Libraries
--------------------------

If all you need to do is add some functionality to an existing library - perhaps add a function or two - then it's overkill to replace the entire library with your version. In this case it's better to simply extend the class. Extending a class is nearly identical to replacing a class with a couple exceptions:

The class declaration must extend the parent class.
Your new class name and filename must be prefixed with MY_ (this item is configurable. See below.).
For example, to extend the native Email class you'll create a file named ```application/libraries/MY_Email.php```, and declare your class with:

	class MY_Email extends CI_Email {

	}
	
Note: If you need to use a constructor in your class make sure you extend the parent constructor:

	class MY_Email extends CI_Email {

	    public function __construct()
	    {
	        parent::__construct();
	    }
	}
	
Loading Your Sub-class
----------------------

To load your sub-class you'll use the standard syntax normally used. DO NOT include your prefix. For example, to load the example above, which extends the Email class, you will use:

	$this->load->library('email');

Once loaded you will use the class variable as you normally would for the class you are extending. In the case of the email class all calls will use:

	$this->email->some_function();

Setting Your Own Prefix
-----------------------

To set your own sub-class prefix, open your application/config/config.php file and look for this item:

	$config['subclass_prefix'] = 'MY_';
	
Please note that all native CodeIgniter libraries are prefixed with CI_ so DO NOT use that as your prefix.
	

CREATING HELPERS
----------------
	
Helpers are simply a collection of functions that we can use in our codeigniter script. The function can be used either in Controller, View and even Models. What the functions do is up to us to decide.
	
Simple way to decide either to build a function of a library is by looking at its usage and complexity. If the features can be group into one then it may be more suitable to be library. If what wee are looking at are simple 1 function which we need to be available throughout the application then helpers are the answer.

File Location
-------------

All of our own helpers should be located at ```applications/helpers/name_helper.php``` with name is our helper file name.

	
> Note: helper file name should end with _helper.php for it to work.
	
Example, create new file ```application/helpers/self_helper.php``` and put codes below as an example
	
	function dumper($multi){
		
		echo '<pre><code>';
		var_dump($multi);
		echo '</code></pre>';
		
	}
	

Initialize/Load helper
----------------------

Load the helper anywhere inside MVC by using common ```$this->load->helper();``` and only user the name without _helper.php.
	
	$this->load->helper('self');
	
Now, we can use any function inside that helper files. In this example, we try to use dumper();
	
	$this->load->helper('self');
	
	dumper(array('testing', 1, 2, 3));
	dumper($_POST);
	
	
Using CodeIgniter '$this' inside Helpers File
---------------------------------------------

There will come a time when we like to use many of Codeigniter libraries and class inside helper. However, because the structure of helper functions are not bind to any class, it cannot inherit class and methods from any of CodeIgniter class. Thus hindered us from using ```$this->``` directly inside helpers function.
	
However, we can use PHP native get_instance to force inheritance.
	
Example, create new function inside our previous self_helper with the code below:

	function dump_sess(){
		$CI =&get_instance();
		dumper($CI->session->all_userdata());
	}

This function will use previously define function ```dumper()``` and display all Codeigniter Session data. See that we force inheritance of Codeigniter ```$this``` into ```$CI```. 

Thus we can now use any of CodeIgniter class function.



Session 5: CodeIgniter Best Practice
====================================

Thin Controller Fat Model
-------------------------

Utilize Libraries and Helpers
-----------------------------

Do then Optimize
----------------


Project: News Board (ala HackerNews)
====================================

Phase 1: Wireframe and UI design (Pen + Paper)
----------------------------------------------
	
Phase 2: Site Structure and Navigation (CI)
-------------------------------------------
	
Phase 3: Registration and Login System
--------------------------------------
	
Phase 4: News Board CRUD
------------------------
	
Phase 5: Discussion CRUD
------------------------

	



	


	


	



Project 1: Simple ACL with CodeIgniter


	

 
	


